#include "compiler.h"
#include "lexer.h"
#include <stdio.h>

/******************************************************************************
 *                                   语法分析
 * 词法分析 >> 单词信息体 》》  语法分析器  》》 语法分析树 -> 抽象语法树
 * 原理：LL(1)右读向下分析文法 + 表达式算符优先文法
 *****************************************************************************/
// 维护函数
单词信息体 读入下一单词();

// LL(1) 产生式对应函数;
void 表达式_算符优先解析();

void 常数表达式_解析();

void 文件_解析();
void 包声明_解析();
void 导入声明_解析();
    void 导入声明尾_解析();
    void 导入描述组_解析();
    void 导入描述行_解析();

void 访问修饰声明_解析();
void 声明_解析();
void 类型声明_解析();
    void 类型声明尾_解析();
    void 类型描述组_解析();
    void 类型描述行_解析();
        void 类型描述_解析();
        void 基本类型名_解析();
        void 构造类型描述_解析();
            void 地址类型描述_解析();
            void 数组类型描述_解析();
            void 结构体描述_解析();
            void 共用体描述_解析();
                void 字段组_解析();
                void 访问修饰字段行_解析();
                void 字段行_解析();
            void 枚举体描述_解析();
                

    void 常量声明_解析();
        void 常量声明尾_解析();
        void 常量描述组_解析();
        void 常量描述行_解析();
    void 变量声明_解析();
        void 变量声明尾_解析();
        void 变量描述组_解析();
        void 变量描述行_解析();
    void 宏声明_解析();
    void 过程声明_解析();
    void 类声明_解析();
    void 函数声明_解析();
    void 算符声明_解析();


/******************************************************************************
 * 语法分析器：每次从“词法分析器”获取一个“单词”，解析构建 语法树 和 抽象语法树
 * 
 *****************************************************************************/
FILE * 输入文件_语法分析;
单词信息体 当前单词;

// 过滤 无效单词，更新 “当前单词”信息体
单词信息体 读入下一单词() {
    单词信息体 新单词信息体;
    // 掠过无用的 注释、空单词、续行符
    do{
        新单词信息体 = 文件_扫描单词(输入文件_语法分析);
    }while(新单词信息体.类型==注释 || 新单词信息体.类型==空单词 || 新单词信息体.类型==续行符);
    当前单词 = 新单词信息体;
    return 新单词信息体;
}
// 错误处理：当遇到错误时，跳过部分语句的解析，而不是全部停止


/*《文件》： 《包声明》 《导入声明》 《声明》 */
void 文件_解析() {
    包声明_解析();
    导入声明_解析();
    访问修饰声明_解析();
}
/*《包声明》： package保留词 标识符 \n */
void 包声明_解析() {
    if (当前单词.类型 == 包) {
        读入下一单词();
        // 动作
        标识符_解析();
        if (当前单词.类型 == 换行) {
            读入下一单词();
            // 动作 不过换行一般没有动作
        } else {
            // 报错
        }
    } else {
        // 报错
    }
}
/*《导入声明》： import保留词 《导入声明尾》 */
void 导入声明_解析() {
    if (当前单词.类型 == 导入) {
        读入下一单词();
        // 动作
        导入声明尾_解析();
    } else {
        // 报错
    }
}
/*《导入声明尾》：《导入描述行》 | "(" \n 《导入描述组》 ")" \n  //别名可选，行任意重复 */
void 导入声明尾_解析() {
    //多行 导入声明
    if(当前单词.类型==标识符 || 当前单词.类型==字符串字面量) { // 《导入描述行》 首符集
        // 动作
        导入描述行_解析();
    }else if (当前单词.类型 == 左圆括号) { // "("
        // 动作
        读入下一单词();
        if (当前单词.类型 == 换行) { // \n
            读入下一单词();
            导入描述组_解析();      // 《导入描述组》
        } else {/* 报错 */}
        if (当前单词.类型 == 右圆括号) { // )
            读入下一单词();
        } else {/* 报错 */}
        if (当前单词.类型 == 换行) { // \n
            读入下一单词();
        } else {/* 报错 */}
    }else {
        // 报错
    }
}
//《导入描述组》：《导入描述行》《导入描述组》|\n 《导入描述组》| ε
void 导入描述组_解析() {
    if(当前单词.类型==标识符 || 当前单词.类型==字符串字面量) { // 《导入描述行》 首符集
        导入描述组_解析();
    }else if(当前单词.类型==换行){
        // 空行
        读入下一单词();
        导入描述组_解析();
    }else if(当前单词.类型==右圆括号){ //《导入描述组》 FOLLOW集 {")"}
        // 动作
        读入下一单词();
        return;
    }else {
        // 报错
    }
}
//《导入描述行》：标识符:别名 字符串:路径 \n | 字符串:路径 \n
void 导入描述行_解析() {
    if (当前单词.类型==标识符) { // 标识符:别名 字符串:路径 \n
        读入下一单词();
        if (当前单词.类型==字符串字面量){
            读入下一单词();
        }else{/*报错*/}
        if (当前单词.类型==换行){
            读入下一单词();
        }else {/*报错*/}
    }else if (当前单词.类型==字符串字面量) { // 字符串:路径 \n
        读入下一单词();
        if (当前单词.类型==换行){
            读入下一单词();
        }else {/*报错*/}
    }else {
        // 报错
    }
}
//《默认声明》 首符集 {const var type proc class func }
/*《声明》：《默认声明》 | "+" 《默认声明》 | "-" 《默认声明》| 空 \n */
void 访问修饰声明_解析() {
    switch (当前单词.类型){
    case 加号: //访问控制 public
        // 动作
        读入下一单词(); 声明_解析();
        break;
    case 减号: //访问控制 private
        // 动作
        读入下一单词(); 声明_解析();
        break;
    // 《默认声明》 首符集
    case 宏:   声明_解析(); break;
    case 类型: 声明_解析(); break;
    case 常量: 声明_解析(); break;
    case 变量: 声明_解析(); break;
    case 过程: 声明_解析(); break;
    case 类:   声明_解析(); break;
    case 函数: 声明_解析(); break;
    case 算符: 声明_解析(); break;
    default:
        // 报错
        break;
    }
}
//《默认声明》：《宏声明》|《类型声明》|《常量声明》|《变量声明》|《过程声明》|《类声明》|《函数声明》|《算符声明》
void 声明_解析() {
    switch (当前单词.类型) {
    // 《默认声明》 首符集
    case 宏:   宏声明_解析();   break;
    case 类型: 类型声明_解析(); break;
    case 常量: 常量声明_解析(); break;
    case 变量: 变量声明_解析(); break;
    case 过程: 过程声明_解析(); break;
    case 类:    类声明_解析(); break;
    case 函数: 函数声明_解析(); break;
    case 算符: 算符声明_解析(); break;
    default:
        // 报错
        break;
    }
}
//《类型声明》：type保留词 《类型声明尾》
void 类型声明_解析() {
    if (当前单词.类型==类型) {
        // 动作
        读入下一单词();
        类型声明尾_解析();
    } else {
        // 报错
    }
}
//《类型声明尾》： 《类型描述行》 | "("  \n  《类型描述组》  ")"  \n
void 类型声明尾_解析() {
    if (当前单词.类型==标识符) {
        // 动作
        类型描述行_解析();
    }else if(当前单词.类型==左圆括号) {
        // 动作
        读入下一单词();
        类型描述组_解析();
    }else{
        // 报错
    }
}
//《类型描述组》： 《类型描述行》《类型描述组》 | \n 《类型描述组》 | ε
void 类型描述组_解析() {
    if (当前单词.类型==标识符) {
        // 动作
        类型描述行_解析();
    }else if(当前单词.类型==换行) { // 空行
        读入下一单词();
    }else if(当前单词.类型==右圆括号) { //《类型描述组》 FOLLOW集{")"}
        读入下一单词();
        return;
    }else {
        // 报错
    }
}
//《类型描述行》： 标识符:类型名 《类型描述》 \n
void 类型描述行_解析() {
    if (当前单词.类型==标识符) {
        // 动作
        读入下一单词();
        类型描述_解析();
        if (当前单词.类型==换行) {
            读入下一单词();
        }else{/* 报错 */}
    }else {
        // 报错
    }
}
//《类型描述》： 《基本类型名》|《构造类型描述》
void 类型描述_解析() {
    switch(当前单词.类型) {
    case 数据型: case 逻辑型:
    case 自然型: case 自然型8: case 自然型16: case 自然型32: case 自然型64:
    case 整型: case 整型8: case 整型16: case 整型32: case 整型64:
    case 浮点: case 浮点32: case 浮点64:
    case 字符: case 字符8: case 字符16: case 字符32:
    case ascii字符:
        基本类型名_解析();
        break;
    case 单线右单箭头:
    case 左方括号:
    case 结构体:
    case 共用体:
    case 枚举体:
        构造类型描述_解析();
        break;
    default:
        // 报错
        break;
    }
}
/*《基本类型名》: 逻辑型 数据型|自然型|自然型8|自然型16|自然型32|自然型64
                |整型|整型8|整型16|整型32|整型64
				| 浮点 | 浮点32 | 浮点64 
				| 字符 | 字符8 | 字符16 | 字符32 | ascii字符  */ 
void 基本类型名_解析() {
    switch (当前单词.类型){
    case 数据型: case 逻辑型:
    case 自然型: case 自然型8: case 自然型16: case 自然型32: case 自然型64:
    case 整型: case 整型8: case 整型16: case 整型32: case 整型64:
    case 浮点: case 浮点32: case 浮点64:
    case 字符: case 字符8: case 字符16: case 字符32:
    case ascii字符:
        // 动作
        读入下一单词();
        break;
    default:
        // 报错
        break;
    }
}
// 《构造类型描述》： 《地址类型描述》|《数组类型描述》|《结构体描述》|《共用体描述》|《枚举体描述》
void 构造类型描述_解析() {
    switch (当前单词.类型) {
    case 单线右单箭头:
        // 动作
        地址类型描述_解析();
        break;
    case 左方括号:
        // 动作
        数组类型描述_解析();
        break;
    case 结构体:
        // 动作
        结构体描述_解析();
        break;
    case 共用体:
        // 动作
        共用体描述_解析();
    case 枚举体:
        // 动作
        枚举体描述_解析();
        break;
    default:
        // 报错
        break;
    }
}
// 《地址类型描述》： "->" 《类型描述》
void 地址类型描述_解析() {
    if (当前单词.类型==单线右单箭头) {
        // 动作
        读入下一单词();
        类型描述_解析();
    }else {
        // 报错
    }
}
// 《数组类型描述》： "["  《常数表达式》:容量  "]"  《类型描述》
void 数组类型描述_解析() {
    if (当前单词.类型==左方括号) {
        // 动作
        读入下一单词();
        常数表达式_解析();
        if (当前单词.类型==右方括号) {
            // 动作
            读入下一单词();
            类型描述_解析();
        }else{
            // 报错 右方括号缺失
        }
    }else {
        // 报错
    }
}
// 《结构体描述》： struct保留词  "{" \n 《字段组》  "}"  \n
void 结构体描述_解析() {
    if (当前单词.类型==结构体) {
        // 动作
        读入下一单词();
    }else {/* 报错 */}
    if (当前单词.类型==左花括号) {
        // 动作
        读入下一单词();
    }else {/* 报错 */}
    if (当前单词.类型==换行) {
        读入下一单词();
    }else{/* 报错 */}
    字段组_解析();
    if (当前单词.类型==右花括号) {
        // 动作
        读入下一单词();
    }else {/* 报错 */}
    if (当前单词.类型==换行) {
        读入下一单词();
    }else{/* 报错 */}
}
//《字段组》： 《访问修饰字段行》 《字段组》 | \n 《字段组》| ε
void 字段组_解析() {
    // 《访问修饰字段行》 FIRST首符集{"+"、"-"、标识符}
    if(当前单词.类型==标识符 || 当前单词.类型==加号 || 当前单词.类型==减号) {
        // 动作
        访问修饰字段行_解析();
    }else if(当前单词.类型==换行) {
        // 空行
        读入下一单词();
    }else if (当前单词.类型==右花括号) { //《字段组》 FOLLOW随符集{"}"}
        // 动作
        读入下一单词();
    }else {
        // 报错
    }
}
// 《访问修饰字段行》： 《字段行》 | "+" 《字段行》 | "-" 《字段行》
void 访问修饰字段行_解析() {
    if (当前单词.类型==标识符) {
        字段行_解析();
    }else if(当前单词.类型==加号 || 当前单词.类型==减号) {
        // 动作
        读入下一单词();
        字段行_解析();
    }else {
        // 报错
    }
}
// 《字段行》： 标识符:字段名 《类型描述》 \n ;字段行暂不支持逗号","分隔
void 字段行_解析() {
    if (当前单词.类型==标识符) {
        // 动作
        读入下一单词();
    }else {/* 报错 */}
    类型描述_解析();
    if (当前单词.类型==换行) {
        读入下一单词();
    }else {/* 报错 */}
}
// 《共用体描述》： union保留词   "{" \n 《字段组》  "}"  \n
void 共用体描述_解析() {
    if (当前单词.类型==共用体) {
        // 动作
        读入下一单词();
    }else {/* 报错 */}
    if (当前单词.类型==左花括号) {
        // 动作
        读入下一单词();
    }else {/* 报错 */}
    if (当前单词.类型==换行) {
        读入下一单词();
    }else{/* 报错 */}
    字段组_解析();
    if (当前单词.类型==右花括号) {
        // 动作
        读入下一单词();
    }else {/* 报错 */}
    if (当前单词.类型==换行) {
        读入下一单词();
    }else{/* 报错 */}
}
// 《枚举体描述》： enum保留词 "{" \n 《枚举成员列表》 "}" "\n"
void 枚举体描述_解析() {
    if(当前单词.类型==枚举体) {
        // 动作
        读入下一单词();
    }else {/* 报错 */}
    if (当前单词.类型==左花括号) {
        // 动作
        读入下一单词();
    }else {/* 报错 */}
    if (当前单词.类型==换行) {
        读入下一单词();
    }else{/* 报错 */}
    枚举成员列表_解析();
    if (当前单词.类型==右花括号) {
        // 动作
        读入下一单词();
    }else {/* 报错 */}
    if (当前单词.类型==换行) {
        读入下一单词();
    }else{/* 报错 */}
}
// 《枚举成员列表》： 《枚举成员》《枚举成员列表》| \n 《枚举成员列表》| ε
void 枚举成员列表_解析() {
    if(当前单词.类型==标识符) {
        // 动作
        枚举成员_解析();
        枚举成员列表_解析();
    }else if(当前单词.类型==换行) {
        读入下一单词();
    }else if(当前单词.类型==右花括号) { // 《枚举成员列表》 FOLLOW随符集{"}"}
        // 动作
        读入下一单词();
    }else{  
        // 报错
    }
}
// 《枚举成员》： 标识符:成员名 (赋值号 常数:枚举值)?
void 枚举成员_解析() {
    if(当前单词.类型==标识符) {
        // 动作
        读入下一单词();
        if(当前单词.类型==等于号) {
            // 动作
            读入下一单词();
            if(当前单词.类型==数字字面量) {
                // 动作
                读入下一单词();
            }else {/* 报错 */}
        }else if(当前单词.类型==逗号) { // FOLLOW随符集{","}
            return;
        }else{
            // 报错
        }
    }else{
        // 报错
    }
}
// 



//《常量声明》： const保留词 《常量声明尾》
void 常量声明_解析() {
    if (当前单词.类型==常量) {
        // 动作
        读入下一单词();
        常量声明尾_解析();
    } else {
        // 报错
    }
}
//《常量声明尾》：《常量描述行》 | "("  \n  《常量描述行》*  ")"  \n
void 常量声明尾_解析() {
    if (当前单词.类型==常量) {
        // 动作
        常量描述行_解析();
    }else if(当前单词.类型==左圆括号){
        // 动作
        读入下一单词();
        if (当前单词.类型==换行){ //换行没有动作
            读入下一单词();
        }else{/* 报错 */}
        常量描述组_解析();
        if (当前单词.类型==右圆括号){
            // 动作
            读入下一单词();
        }else {/* 报错 */}
        if (当前单词.类型==换行) { //换行没有动作
            读入下一单词();
        }else {/* 报错 */}
    }else{
        // 报错
    }
}
//《常量描述组》： 《常量描述行》《常量描述组》 | \n 《常量描述组》| ε
void 常量描述组_解析() {
    if(当前单词.类型==常量) {
        常量描述行_解析();
    }else if(当前单词.类型==换行){
        // 空行
        读入下一单词();
    }else if(当前单词.类型==右圆括号) { // 《常量描述组》 FOLLOW集 {")"}
        // 动作
        读入下一单词();
        return;
    }else{
        // 报错
    }
}
//《类型声明》：type保留词 《类型声明尾》
void 常量描述行_解析() {

}
